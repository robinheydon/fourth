///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

const std = @import("std");
const builtin = @import("builtin");

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

const ng = @import("ng.zig");
const event = @import("event.zig");
const x11 = @import("x11.zig");
const color = @import("color.zig");

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub const Event = event.Event;
pub const Color = color.Color;

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

var initialized = false;

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub const VideoError = error{
    CannotOpenWindow,
    CannotCreateShader,
    TooManyShaders,
    InvalidShaderIndex,
    UnknownVertexAttribute,
    TooManyBuffers,
    TooManyPipelines,
    TooManyBindings,
};

pub const Platform = struct {
    deinit: *const fn () void,

    create_window: *const fn (CreateWindowOptions) VideoError!Window,
    close_window: *const fn (Window) void,
    get_window_size: *const fn (Window) WindowSize,

    acquire_command_buffer: *const fn (Window) VideoError!CommandBuffer,
    submit_command_buffer: *const fn (CommandBuffer) VideoError!void,
    acquire_swapchain_texture: *const fn (CommandBuffer) VideoError!GPUTexture,

    begin_render_pass: *const fn (CommandBuffer, BeginRenderPassInfo) VideoError!RenderPass,
    end_render_pass: *const fn (RenderPass) void,
    apply_pipeline: *const fn (RenderPass, Pipeline) void,
    apply_bindings: *const fn (RenderPass, Bindings) void,
    apply_uniform: *const fn (RenderPass, UniformInfo) void,
    draw: *const fn (RenderPass, u32) void,

    create_shader: *const fn (CreateShaderInfo) VideoError!Shader,
    delete_shader: *const fn (Shader) void,

    create_buffer: *const fn (CreateBufferInfo) VideoError!Buffer,
    delete_buffer: *const fn (Buffer) void,

    create_pipeline: *const fn (CreatePipelineInfo) VideoError!Pipeline,
    delete_pipeline: *const fn (Pipeline) void,

    create_bindings: *const fn (CreateBindingsInfo) VideoError!Bindings,
    delete_bindings: *const fn (Bindings) void,

    poll_event: *const fn () ?ng.Event,
};

var platform: Platform = undefined;

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub fn init() !void {
    if (x11.init()) |plat| {
        platform = plat;
    } else |_| {
        return error.NoVideoPlatform;
    }

    initialized = true;
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub fn deinit() void {
    if (initialized) {
        platform.deinit();
    }
    initialized = false;
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub const Window = struct {
    handle: usize,

    pub fn close(self: Window) void {
        platform.close_window(self);
    }

    pub fn get_size (self: Window) WindowSize {
        return platform.get_window_size (self);
    }

    pub fn acquire_command_buffer(self: Window) !CommandBuffer {
        return platform.acquire_command_buffer(self);
    }
};

pub const WindowSize = struct {
    width: f32,
    height: f32,
};

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub fn create_window(options: CreateWindowOptions) !Window {
    if (!initialized) return error.VideoNotInitialized;

    return platform.create_window(options);
}

pub const CreateWindowOptions = struct {
    name: ?[*:0]const u8 = null,
    width: ?u32 = null,
    height: ?u32 = null,
    resizable: bool = false,
    fullscreen: bool = false,
    gl_major_version: u32 = 4,
    gl_minor_version: u32 = 6,
};

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub fn poll_event() ?Event {
    return platform.poll_event();
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub const CommandBuffer = struct {
    handle: usize,

    pub fn acquire_swapchain_texture(self: CommandBuffer) VideoError!GPUTexture {
        return platform.acquire_swapchain_texture(self);
    }

    pub fn begin_render_pass(self: CommandBuffer, info: BeginRenderPassInfo) VideoError!RenderPass {
        return platform.begin_render_pass(self, info);
    }

    pub fn submit(self: CommandBuffer) VideoError!void {
        return platform.submit_command_buffer(self);
    }
};

pub const BeginRenderPassInfo = struct {
    texture: GPUTexture,
    clear_color: Color = .black,
    load: LoadOp = .clear,
    store: StoreOp = .store,
};

const LoadOp = enum {
    clear,
    load,
    dont_care,
};

const StoreOp = enum {
    store,
    dont_care,
    resolve,
    resolve_and_store,
};

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub const GPUTexture = struct {
    handle: usize,
};

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub const RenderPass = struct {
    handle: usize,

    pub fn end(self: RenderPass) void {
        platform.end_render_pass(self);
    }

    pub fn apply_pipeline(self: RenderPass, pipeline: Pipeline) void {
        platform.apply_pipeline(self, pipeline);
    }

    pub fn apply_bindings(self: RenderPass, bindings: Bindings) void {
        platform.apply_bindings(self, bindings);
    }

    pub fn apply_uniform(self: RenderPass, index: anytype, data: anytype) void {
        const info: UniformInfo = .{
            .index = @intFromEnum (index),
            .data = ng.as_bytes(data),
        };
        platform.apply_uniform(self, info);
    }

    pub fn draw(self: RenderPass, num_vertexes: u32) void {
        platform.draw(self, num_vertexes);
    }
};

pub const UniformInfo = struct {
    index: u32,
    data: []const u8,
};

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub const max_vertex_attributes = 32;

pub const CreateShaderInfo = struct {
    label: ?[]const u8,
    vertex_source: [*:0]const u8,
    fragment_source: [*:0]const u8,

    vertex_attrib: [max_vertex_attributes]VertexAttribute = .{VertexAttribute{}} ** max_vertex_attributes,
};

pub const VertexAttribute = struct {
    size: usize = 0,
    vertex_type: VertexType = .unknown,
    normalize: bool = false,
    stride: usize = 0,
    offset: usize = 0,
};

pub const VertexType = enum(u32) {
    unknown,
    i8 = 0x1400,
    u8 = 0x1401,
    i16 = 0x1402,
    u16 = 0x1403,
    i32 = 0x1404,
    u32 = 0x1405,
    f32 = 0x1406,
    f64 = 0x140A,
    f16 = 0x140B,
};

pub const Shader = struct {
    handle: usize,

    pub fn delete(self: Shader) void {
        platform.delete_shader(self);
    }
};

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub fn create_shader(shader: anytype) VideoError!Shader {
    var info: CreateShaderInfo = .{
        .label = shader.label,
        .vertex_source = shader.vertex_source,
        .fragment_source = shader.fragment_source,
    };

    try build_vertex_attributes(&info, shader.Vertex);

    return platform.create_shader(info);
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

fn build_vertex_attributes(info: *CreateShaderInfo, T: type) !void {
    const t_size = @sizeOf(T);
    inline for (0.., std.meta.fields(T)) |i, field| {
        var attr = try attribute_info(field.type);
        attr.stride = t_size;
        attr.offset = @offsetOf(T, field.name);

        info.vertex_attrib[i] = attr;
    }
}

fn attribute_info(comptime T: type) !VertexAttribute {
    switch (T) {
        u8 => return .{
            .size = 1,
            .vertex_type = .u8,
        },
        i8 => return .{
            .size = 1,
            .vertex_type = .i8,
        },
        Color => return .{
            .size = 4,
            .vertex_type = .u8,
            .normalize = true,
        },
        f32 => return .{
            .size = 1,
            .vertex_type = .f32,
        },
        [2]f32 => return .{
            .size = 2,
            .vertex_type = .f32,
        },
        [3]f32 => return .{
            .size = 3,
            .vertex_type = .f32,
        },
        [4]f32 => return .{
            .size = 4,
            .vertex_type = .f32,
        },
        [16]f32 => return .{
            .size = 16,
            .vertex_type = .f32,
        },
        else => {},
    }
    std.debug.print("Unknown vertex attribute type : {s}\n", .{@typeName(T)});
    return error.UnknownVertexAttribute;
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub const CreateBufferInfo = struct {
    label: ?[]const u8,
    kind: BufferKind = .vertex_data,
    data: ?[]u8 = null,
    update: BufferUpdate = .static,
};

pub const BufferKind = enum {
    vertex_data,
    index_data,
};

pub const BufferUpdate = enum {
    static,
    stream,
    dynamic,
};

pub const Buffer = struct {
    handle: usize,

    pub fn delete(self: Buffer) void {
        platform.delete_buffer(self);
    }
};

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub fn create_buffer(info: CreateBufferInfo) !Buffer {
    return platform.create_buffer(info);
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub const CreatePipelineInfo = struct {
    label: ?[]const u8 = null,
    shader: Shader,
    primitive: Primitive,
};

pub const Primitive = enum {
    triangle_list,
    triangle_strip,
    line_list,
    line_strip,
    point_list,
};

pub const Pipeline = struct {
    handle: usize,

    pub fn delete(self: Pipeline) void {
        platform.delete_pipeline(self);
    }
};

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub fn create_pipeline(info: CreatePipelineInfo) !Pipeline {
    return platform.create_pipeline(info);
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub const CreateBindingsInfo = struct {
    label: ?[]const u8 = null,
    vertex_buffers: ?[]const Buffer = null,
    index_buffers: ?[]const Buffer = null,
};

pub const Bindings = struct {
    handle: usize,

    pub fn delete(self: Bindings) void {
        platform.delete_bindings(self);
    }
};

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub fn create_bindings(info: CreateBindingsInfo) !Bindings {
    return platform.create_bindings(info);
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
