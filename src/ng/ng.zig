///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

const std = @import("std");

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

const video = @import("video.zig");
const audio = @import("audio.zig");
const event = @import("event.zig");
const api = @import("api.zig");
const time = @import("time.zig");
const math = @import("math.zig");
const color = @import("color.zig");

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub const lookup_symbols = api.lookup_symbols;
pub const lookup_using = api.lookup_using;

pub const create_window = video.create_window;
pub const create_shader = video.create_shader;
pub const create_buffer = video.create_buffer;
pub const create_pipeline = video.create_pipeline;
pub const create_bindings = video.create_bindings;

pub const Vec2 = math.Vec2;
pub const Vec3 = math.Vec3;
pub const Vec4 = math.Vec4;
pub const Mat4 = math.Mat4;
pub const mat4_identity = math.mat4_identity;
pub const ortho = math.ortho;
pub const mat4_mul = math.mat4_mul;
pub const Camera2D = math.Camera2D;

pub const Color = color.Color;

pub const Event = event.Event;

pub const elapsed = time.elapsed;

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub var prng: std.Random.DefaultPrng = undefined;

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub fn init(options: InitOptions) !void {
    if (options.video) {
        try video.init();
    }
    if (options.audio) {
        try audio.init();
    }

    time.init();
    const now = time.wallclock_us();

    prng = std.Random.DefaultPrng.init(now);
}

pub const InitOptions = struct {
    video: bool = false,
    audio: bool = false,
};

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub fn deinit() void {
    video.deinit();
    audio.deinit();
    time.deinit();
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub fn poll_event() ?Event {
    return video.poll_event();
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub fn rand() f32 {
    const random = prng.random();
    return random.float(f32);
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub fn as_bytes(data: anytype) []u8 {
    const T = @TypeOf(data);
    const ti = @typeInfo(T);

    const ptr = std.mem.asBytes(data);
    var block: []u8 = undefined;
    block.ptr = @constCast(ptr);
    block.len = @sizeOf(ti.pointer.child);
    return block;
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

test "as_bytes" {
    {
        const a: u8 = 0x12;
        const b = as_bytes(&a);
        std.debug.print("b = {any}\n", .{b});
    }

    {
        const a: u16 = 0x1234;
        const b = as_bytes(&a);
        std.debug.print("b = {any}\n", .{b});
    }

    {
        const a: u32 = 0x12345678;
        const b = std.mem.asBytes(&a);
        std.debug.print("b = {any}\n", .{b});
    }

    {
        const a: u64 = 0x12345678_9abcdef0;
        const b = std.mem.asBytes(&a);
        std.debug.print("b = {any}\n", .{b});
    }

    {
        const a: f32 = 3.14;
        const b = std.mem.asBytes(&a);
        std.debug.print("b = {any}\n", .{b});
    }

    {
        const a: f64 = 3.14;
        const b = std.mem.asBytes(&a);
        std.debug.print("b = {any}\n", .{b});
    }

    {
        const a: [3]u8 = .{ 1, 2, 3 };
        const b = std.mem.asBytes(&a);
        std.debug.print("b = {any}\n", .{b});
    }

    {
        const a: [3]f32 = .{ 1, 2, 3 };
        const b = std.mem.asBytes(&a);
        std.debug.print("b = {any}\n", .{b});
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub fn make_uniform_slots(comptime Uniforms: type) type {
    var fields : [16]std.builtin.Type.EnumField = undefined;

    var num_fields: usize = 0;

    inline for (std.meta.fields (Uniforms)) |field|
    {
        fields[num_fields].value = num_fields;
        fields[num_fields].name = field.name;
        num_fields += 1;
    }

    const info = std.builtin.Type{ .@"enum" = .{
        .tag_type = u32,
        .fields = fields[0..num_fields],
        .decls = &.{},
        .is_exhaustive = true,
    } };

    return @Type(info);
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
